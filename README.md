# Algorithm_TIN


## TINアルゴリズム(グリッドからTIN)
1. TINに含まれるすべての頂点$v$について :
    
    * 一時的に頂点 $v$ を削除．
    * 削除した頂点を除いて，Delaunay三角網を構築．
    * 新たなTINを用いて，頂点 $v$ の標高誤差 $error(v)$ を計算．

    ソートされた各頂点 $v$ の誤差 $error(v)$ を 平衡二分木(balanced binary tree) $T$ に格納する． $T$ の各ノードは誤差 $error(v)$ とTINの頂点 $v$ へのポインタを保持している．  
    また頂点 $v$ には， $T$ の対応するノードへのポインタを格納する.

2. $T$ において，最小の $error(v)$ を持つノードについて検討する．もしその $error(v)$ が，設定した最大誤差よりも大きければ，ここでアルゴリズムを終了する．そうでないとき，次のステップへ進む．

3. $error(v)$ を持つ $T$ のノードを削除する．そして対応する頂点 $v$ をTIN構造体から削除する．  
頂点 $v$ の隣接する頂点を $w_1, w_2, ..., w_j$ とする．そして頂点 $w_1, w_2, ..., w_j$ を用いて，再度ドローネ三角分割を行う．

4. すべての頂点 $w_i \in \{w_1, w_2, ..., w_j\}$ について : 

    * $error(w_i)$ を保持しているノードを $T$ から削除．
    * Step1で行ったように，頂点 $w_i$ を削除した際の標高誤差 $error(w_i)$ を計算．
    * 新たに求めた $error(w_i)$ を $T$ に代入．

Step2へ続く  


#### 参考文献
> Marc van Kreveld，Jürg Nievergelt，Thomas Roos，Peter Widmayer (Eds.): Algorithmic Foundations of Geographic Information Systems，Springer，pp．47-50，1997．



## ドローネ三角分割(Delaunay Triangulation)

アルゴリズムに関する情報は，[Algorithm_Delaunay](https://github.com/aoken0/Algorithm_Delaunay) を参照．


## 重心座標系(Barycentric coordinate system)

ある三角形に内包されている点について、標高を線形補間で求める。

### 数式等
任意の点を $P$ ，点 $P$ を内包する三角形の頂点をそれぞれ $A, B, C$ とする．またそれぞれの点の標高(重み)は $P_h, A_h, B_h, C_h$ とする．  
重心座標系を用いると任意の点 $P$ の座標・標高は以下のように表せる．

```math
\begin{align*}
P &= \lambda_1 A + \lambda_2 B + \lambda_2 C \\
P_h &= \lambda_1 A_h + \lambda_2 B_h + \lambda_2 C_h \\
\end{align*}
```

&emsp;

そして $\lambda_1, \lambda_2, \lambda_3$ は以下のように求められる．  
面積を $area()$ として， 

```math
\begin{align*}
\lambda_1 &=& area(PBC) / area(ABC) \\
\lambda_2 &=& area(APC) / area(ABC) \\
\lambda_3 &=& area(ABP) / area(ABC) \\
\end{align*}
```

となる．また

```math
\begin{align*}
1 = \lambda_1 + \lambda_2 + \lambda_3
\end{align*}
```

である．

ここで面積はベクトルの外積を用いて求めた．  
例)

```math
\begin{align*}
area(ABC) = \frac{1}{2} AB \times AC
\end{align*}
```

> 参考  
> * https://en.wikipedia.org/wiki/Barycentric_coordinate_system



## 実装について

### 不完全なグリッドで分割を行う

グリッド状の点が完全なグリッドであると，delaunay分割の際に分割対象に選択した点群の数や組合せによって異なるdelaunay三角網を返してしまう．

そのため，横もしくは縦方向に少しだけずらした不完全なグリッドを用いることで点群の数や組合せによってdelaunay三角網が異なることを避ける．  

実際最終的な分割目的であるDEMは緯度経度方向で長さが異なり不完全なグリッドであるため，そのまま実行すればよいことになる．

### 現状の実行時間

実行速度は関数を呼び出した瞬間から、最終のTINが取得できるまでの時間で測る．

またアルゴリズムのループにて，debugのために最小標高誤差を出力する(無駄な)処理が入っている．そのため少しだけ実行速度は落ちている．

許容最大誤差が0.1のとき
| 点の数 | 時間 |
|----|----|
| 400 | 6s |
| 2500 | 2m46s |
| 10000 | 46m |

### 実行時間短縮に向けて

現状の実行速度では研究本体に使うグリッド状の点数約75万個を処理するのにとてつもない時間がかかってしまう．そのため，計算時間を短縮するため，工夫してみる．

検証はグリッド状にランダムに生成された $50\times50=2500$ 個の点についてTIN分割を行い，それぞれの実行時間に基づいて行う．

以下は既存のTIN分割関数から工夫した点である．
1. pandasのDataframeをすべてnumpyのndarrayに変換してから処理

2. Step1のすべての点の標高誤差を求める処理にて，削除する点の周囲(最大)24点のみからdelaunay分割を行うようにする．

3. Step3の削除した点に隣接する点の標高誤差の再計算時にdelaunay分割を行う点を制限する．具体的には削除点に接続する3つ先までの点群に対してdelaunay分割を行う．

* $+\alpha$ printを削除

そして実行時間は以下の表に示す．

最大許容誤差が0.1のとき
| 工夫 | 実行時間 |
| ---- | ---- |
| 既存 | 163s |
| 工夫1 | 150s |
| 工夫1~2 | 116s |
| 工夫1~3 | 31s |
| 工夫1~3 $+\alpha$ | 27s |

工夫3について，工夫2までの処理後の点数と比べると2点多く残ってしまっている．しかし全体的な形は変わりなく、1640点が1642点になっているだけなので現段階では許容する．

### 工夫1~3実装後の実行時間

下記表の実行時間は上記の工夫1~3を実装したうえでのものである．またdebug用のprintは削除して実行している．

最大許容誤差が0.1のとき
| 点の数 | 初期 | 工夫1~3 |
| ---- | ---- | ---- |
| 400 | 6s | 2s |
| 2500 | 2m46s | 27s |
| 10000 | 46m | 6m10s |
| 22500 | - | 32m46s |



### さらなる実行時間短縮

実行時間はある程度短縮したものの，依然としてかなり実行時間長いため短縮したい．そのため各処理ごとに時間を計測し，時間がかかっているところに対しアプローチする．


#### 点数を固定した時の各処理の実行時間

点数を2500，最大許容誤差を0.1としたときの各処理の実行時間は以下の通り．

| 処理 | 実行時間 |
| ---- | ---- |
| Step1 | 3.14s |
| 処理1: 削除点の隣接する点及び全三角形を取得 | 24.49s |
| 処理2: 削除点から3つ先までの点群を抽出 | 1.44s |
| 処理3: 削除点に隣接する点の誤差再計算 | 9.68s |
| 処理4: 削除点を配列から削除 | 0.04s |

以上の結果からまず処理1について改善する必要があると分かった．

##### 処理1について

処理1の目的は，削除点から接続している3つ先までの点群を抽出することである．現時点では，すべての点群からdelaunay三角網を計算してから抽出しているが，これは余計な計算量が増えるだけである．しかし削除点からどの程度の点群を抜き出せば適切かを考える必要がある．

グリッド状の点群であれば，削除点から接続している3つ先までの点群は48個(削除点除く)となる．

そのため`scipy.spatial`の`KDTree`を使用して，削除点から近傍の点を個数を指定して取得すれば計算量を減らして目的を達成できる．しかし以下の点に考慮する必要がある．

* 今回は処理のために不完全なグリッド状(アスペクト比が1:1でない)を用いている．そのため削除点からの近傍点を求めるときに，上下と左右で取得できる個数が異なる可能性がある．

* TINが作成されていくと，点の密度が異なってくる．それによってある削除点の左右で密度が異なり，ある点においては先を辿れない状況になりうる．

上記の応急措置として，点群を少し多めに取得するようにした．(現状100個)

#### 処理1: 改善前後の実行時間

点数を2500，最大許容誤差を0.1としたときの改善前後の各処理実行時間は以下の通り．

Step1は変更していないが実行時のパソコンの状態によって実行時間が異なったと思われる．

| 処理 | 実行時間(前) | 実行時間(後) | 
| ---- | ---- | ---- |
| Step1 | 3.14s | 1.84s |
| 処理1: 削除点の隣接する点及び全三角形を取得 | 24.49s | 1.80s |
| 処理2: 削除点から3つ先までの点群を抽出 | 1.44s | 0.39s |
| 処理3: 削除点に隣接する点の誤差再計算 | 9.68s | 3.89s |
| 処理4: 削除点を配列から削除 | 0.04s | 0.08s |

#### 処理1: 改善後の点数による実行時間

最大許容誤差が0.1のとき
| 点の数 | 初期 | 工夫1~3 | 処理1改善 |
| ---- | ---- | ---- | ---- | 
| 400 | 6s | 2s | 2s |
| 2500 | 2m46s | 27s | 9s |
| 10000 | 46m | 6m10s | 39s |
| 22500 | - | 32m46s | 1m47s |



#### Step1

| Step1 | 実行時間 |
| ---- | ---- |
| 2500 | 2s |
| 10000 | 9s |
| 22500 | 16s |

以上の結果からStep1に関しては実行速度はデータに対して約n倍となっている．現状では変更なしでよいと考えられる．



## 本番実行時間メモ

* 点数...999916 (= 行1094 * 列914)

| 最大誤差 | 実行時間 | 実行後の点数 |
| ---- | ---- | ---- |
| 1.0 | 45.37h | 100,535 |
| 2.0 | 45.44h | 53,819 |








